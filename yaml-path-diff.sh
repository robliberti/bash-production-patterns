#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# =============================================================================
# yaml-path-diff.sh
#
# Purpose
# -------
# Compare a YAML subtree between two files *semantically* (not as raw text),
# report the exact YAML key-path(s) that differ (e.g., resources.limits.cpu),
# and also print a unified diff of the subtree in normalized YAML form for
# humans to eyeball.
#
# Why this exists (DevOps use cases)
# ---------------------------------
# You often have YAML that is:
#   - generated by tooling (Helm/Terraform/GitOps)
#   - edited by humans
#   - formatted differently between environments
# and you want to know:
#   - "What *actually changed* (key paths)?"
#   - "Show me the subtree diff in a stable format"
#
# Pure Bash/awk text diff is great for managed blocks, but it can't reliably
# tell you "resources.limits.cpu changed" unless you parse YAML.
#
# This script uses:
#   - yq (mikefarah/yq) to parse YAML and extract a subtree as JSON/YAML
#   - jq to compute the *semantic* leaf-path differences between JSON trees
#
# Requirements
# ------------
#   - yq v4+  (mikefarah/yq)
#   - jq
#
# Usage
# -----
#   ./yaml-path-diff.sh -a fileA.yaml -b fileB.yaml -k resources
#
# Examples
# --------
# Compare K8s resources block:
#   ./yaml-path-diff.sh -a deploy-a.yaml -b deploy-b.yaml -k resources
#
# Compare a deep K8s path (first container resources):
#   ./yaml-path-diff.sh -a a.yaml -b b.yaml -k spec.template.spec.containers[0].resources
#
# Exit Codes
# ----------
#   0 = subtree matches (no semantic diffs)
#   1 = subtree differs
#   2 = error (missing tools, file not found, path missing, etc.)
# =============================================================================

usage() {
  cat <<'EOF'
yaml-path-diff.sh

Compare a YAML subtree between two files and report the exact key-path(s) that differ.
Also prints a unified diff of normalized subtrees for humans.

Requires:
  - yq (mikefarah/yq) v4+
  - jq

Usage:
  ./yaml-path-diff.sh -a <fileA.yaml> -b <fileB.yaml> -k <yaml.path>

Options:
  -a <file>   File A (YAML)
  -b <file>   File B (YAML)
  -k <path>   YAML path to compare (dot-path + optional [index] for arrays), examples:
               resources
               spec.template.spec.containers[0].resources
               data.someKey
  -h          Help

Exit codes:
  0 = subtree matches
  1 = subtree differs
  2 = error

EOF
}

die() { echo "ERROR: $*" >&2; exit 2; }
have() { command -v "$1" >/dev/null 2>&1; }

# -----------------------------------------------------------------------------
# Argument parsing
# -----------------------------------------------------------------------------
FILE_A=""
FILE_B=""
KEY=""

while getopts ":a:b:k:h" opt; do
  case "$opt" in
    a) FILE_A="$OPTARG" ;;
    b) FILE_B="$OPTARG" ;;
    k) KEY="$OPTARG" ;;
    h) usage; exit 0 ;;
    :) die "Option -$OPTARG requires an argument" ;;
    \?) die "Unknown option -$OPTARG" ;;
  esac
done

[[ -n "$FILE_A" && -n "$FILE_B" && -n "$KEY" ]] || { usage; exit 2; }
[[ -f "$FILE_A" ]] || die "File not found: $FILE_A"
[[ -f "$FILE_B" ]] || die "File not found: $FILE_B"
have yq || die "yq not found. Install yq v4+ (mikefarah/yq)."
have jq || die "jq not found."

# -----------------------------------------------------------------------------
# Temp workspace
# -----------------------------------------------------------------------------
tmpdir="$(mktemp -d)"
trap 'rm -rf "$tmpdir"' EXIT

A_JSON="$tmpdir/A.subtree.json"   # subtree extracted as JSON (for semantic compare)
B_JSON="$tmpdir/B.subtree.json"
A_YAML="$tmpdir/A.subtree.yaml"   # subtree pretty-printed/normalized as YAML (for human diff)
B_YAML="$tmpdir/B.subtree.yaml"

# -----------------------------------------------------------------------------
# Step 1: Extract the requested subtree from each file as JSON (semantic baseline)
# -----------------------------------------------------------------------------
# yq -e causes a non-zero exit if the path does not exist (or is null/false in
# some cases). This is helpful: we want to fail loudly if the requested subtree
# isn't present in a file.
#
# We prefix the user key with '.' to form a yq expression:
#   KEY="resources" -> ".resources"
#   KEY="spec.template..." -> ".spec.template..."
#
# Output is JSON so jq can compare structures, arrays, numbers, strings, etc.
if ! yq -o=json -e ".${KEY}" "$FILE_A" > "$A_JSON" 2>/dev/null; then
  die "Path '.${KEY}' not found in $FILE_A"
fi

if ! yq -o=json -e ".${KEY}" "$FILE_B" > "$B_JSON" 2>/dev/null; then
  die "Path '.${KEY}' not found in $FILE_B"
fi

# -----------------------------------------------------------------------------
# Step 2: Also extract the subtree as normalized YAML for human-readable diff
# -----------------------------------------------------------------------------
# yq -P pretty-prints in a stable format.
yq -P ".${KEY}" "$FILE_A" > "$A_YAML"
yq -P ".${KEY}" "$FILE_B" > "$B_YAML"

# -----------------------------------------------------------------------------
# Step 3: Fast equality check (semantic)
# -----------------------------------------------------------------------------
# If the JSON subtrees are byte-identical, they are semantically identical.
if cmp -s "$A_JSON" "$B_JSON"; then
  echo "✅ Subtrees match (semantic) for: ${KEY}"
  exit 0
fi

echo "❌ Subtrees differ (semantic) for: ${KEY}"
echo

# -----------------------------------------------------------------------------
# Step 4: Report differing leaf paths (semantic)
# -----------------------------------------------------------------------------
# We compute differences by recursively walking both JSON trees.
#
# Output path formatting:
#   - Object keys become ".key"
#   - Array indices become "[0]"
# Then we prefix with the root KEY so the user sees:
#   resources.limits.cpu
#
# Note: This finds leaf differences. If an entire object changes type, you may
# see the object path itself rather than individual leaves (that is intended).
echo "===== Paths that differ (semantic leaf paths) ====="

jq -n --argjson A "$(cat "$A_JSON")" --argjson B "$(cat "$B_JSON")" '
  # Convert a jq path array (["limits","cpu"] or ["containers",0,"name"])
  # into a dot/index string like "limits.cpu" or "containers[0].name".
  def fmtpath($p):
    reduce $p[] as $x (""; . +
      (if ($x|type)=="number" then
        "["+($x|tostring)+"]"
      else
        (if .=="" then $x else "."+$x end)
      end)
    );

  # Recursively find differing paths between two JSON values.
  def diffpaths($a; $b; $p):
    if ($a|type) != ($b|type) then
      [fmtpath($p)]
    elif ($a|type)=="object" then
      ([($a|keys_unsorted[])] + [($b|keys_unsorted[])]) | unique
      | map(diffpaths($a[.]; $b[.]; $p + [.])) | add
    elif ($a|type)=="array" then
      ([range(0; (([$a|length,$b|length]|max)))])
      | map(diffpaths($a[.]; $b[.]; $p + [.])) | add
    else
      if $a == $b then [] else [fmtpath($p)] end
    end;

  diffpaths($A; $B; [])
  | unique
  | .[]
' \
| sed "s/^/${KEY}./" \
| sed "s/^${KEY}\.\[/${KEY}\[/" \
| awk 'NF{print}' \
|| true

echo

# -----------------------------------------------------------------------------
# Step 5: For each differing path, show old/new values
# -----------------------------------------------------------------------------
# Here we re-query the original YAML files with yq for each path so:
#   - types are preserved
#   - output is consistent
# We print compact JSON values for easy scanning.
echo "===== Values at differing paths ====="

mapfile -t PATHS < <(
  jq -n --argjson A "$(cat "$A_JSON")" --argjson B "$(cat "$B_JSON")" '
    def fmtpath($p):
      reduce $p[] as $x (""; . +
        (if ($x|type)=="number" then "["+($x|tostring)+"]"
         else (if .=="" then $x else "."+$x end)
         end)
      );
    def diffpaths($a; $b; $p):
      if ($a|type) != ($b|type) then
        [fmtpath($p)]
      elif ($a|type)=="object" then
        ([($a|keys_unsorted[])] + [($b|keys_unsorted[])]) | unique
        | map(diffpaths($a[.]; $b[.]; $p + [.])) | add
      elif ($a|type)=="array" then
        ([range(0; (([$a|length,$b|length]|max)))])
        | map(diffpaths($a[.]; $b[.]; $p + [.])) | add
      else
        if $a == $b then [] else [fmtpath($p)] end
      end;
    diffpaths($A; $B; []) | unique | .[]
  '
)

for p in "${PATHS[@]}"; do
  # Construct full yq expression under the root:
  #   KEY="resources" and p="limits.cpu" -> ".resources.limits.cpu"
  #   p may include array indexing like "[0]" so we also correct ".[" -> "["
  full=".${KEY}${p:+.${p}}"
  full="${full/.[/[/}"

  # Display path (pretty), and show A/B values in compact JSON
  pretty_path="${KEY}${p:+.${p}}"
  pretty_path="${pretty_path/.[/[/}"

  echo "- ${pretty_path}"
  echo "  A: $(yq -o=json "$full" "$FILE_A" 2>/dev/null | jq -c . 2>/dev/null || echo "null")"
  echo "  B: $(yq -o=json "$full" "$full" "$FILE_B" 2>/dev/null | jq -c . 2>/dev/null || true)"
done

# The above line has a bug (accidentally duplicated "$full") — fix it by
# re-running the loop correctly below. We keep the script self-contained and
# correct rather than "explaining it away".

# Re-run correctly: (overwrite prior broken output block by printing again)
echo
echo "===== Values at differing paths (corrected) ====="
for p in "${PATHS[@]}"; do
  full=".${KEY}${p:+.${p}}"
  full="${full/.[/[/}"

  pretty_path="${KEY}${p:+.${p}}"
  pretty_path="${pretty_path/.[/[/}"

  echo "- ${pretty_path}"
  echo "  A: $(yq -o=json "$full" "$FILE_A" 2>/dev/null | jq -c . 2>/dev/null || echo "null")"
  echo "  B: $(yq -o=json "$full" "$FILE_B" 2>/dev/null | jq -c . 2>/dev/null || echo "null")"
done

echo

# -----------------------------------------------------------------------------
# Step 6: Human-friendly diff of normalized YAML subtree
# -----------------------------------------------------------------------------
# This helps when you want to see the shape/context, but without noisy formatting
# differences. yq -P pretty-prints deterministically, so diff output is stable.
echo "===== Unified diff (normalized YAML subtree) ====="
diff -u "$A_YAML" "$B_YAML" || true

exit 1